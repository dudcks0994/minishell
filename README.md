# Minishell
과제 목표 : C99의 제한된 함수들을 이용해 기본적인 기능들을 가진 리눅스 쉘 프로그램 구현

세부 요구사항 및 제한사항은 [여기](https://github.com/dudcks0994/minishell/blob/main/subject.md)

#### heredoc
- 실제 bash는 input 데이터가 파이프 버퍼사이즈보다 작으면 그 안에 저장하는데, 실행파트의 통일성을 위해 임시파일에 저장하는 방법으로 대체
- heredoc 실행 중 시그널은 부모프로세스에게도 전달이 되면 안되므로 부모프로세스에서 특정시그널 무시처리
- 입력종료시, heredoc토큰을 리다이렉션으로 변경 및 임시파일이름을 추가하여 처리
- 여러개 heredoc 실행 중에 종료되는 경우 임시파일들 처리를 위해 따로 파일이름을 리스트에 저장후 관리
#### 환경변수
- export를 통해 환경변수 추가/수정 가능하게끔 환경변수 네이밍 규칙대로 파싱
- 환경변수 치환 이후 다시 메타캐릭터를 통한 토큰화가 이루어지는 bash처럼, 파싱단계가 아닌 실행단계 직전에 환경변수 치환
- 쉘 안에서 프로그램 실행 시, 변경된 환경변수들 적용되게끔 기존 환경변수들을 리스트에따로 담아서 저장후, 실행시 환경변수 새로 만들기
- 각 토큰을 순회하면서 환경변수가 있다면 새로운 문자열을 만들어 치환 이후의 문자열을 만들어 대체

#### 시그널 처리
- bash처럼 쉘 내에 Ctrl+C 와 Ctrl+| 등의 동작이 일반 프로그램과 동작이 다르게끔 설정(리턴코드도 변경)
- $? 구현을 위해 heredoc 및 명령어실행시의 자식프로세스 종료코드를 전역변수로 저장
- 자식프로세스에서 받는 시그널이 부모프로세스에게 영향을 끼치지 않게 SIG_IGN을 이용해 무시

#### 실행부
- 만들어진 토큰을 확인하면서 환경변수 치환 후, 다시 토큰화가 된다면 토큰화(bash)
- 리다이렉션 토큰 확인후 미리 fd확보, 예외처리(권한 및 I/O에러)
- 파이프가 존재 할 경우, 명령어 세트별로 연결 리스트를 만든 뒤 프로그램, 인자, 리다이렉션 파일 fd 를 저장
- fork하면서 파이프 명령어 병렬실행, 파이프를 통해 각 프로세스들의 입력과 출력 연결
- 모든 프로세스들 waitpid로 회수 후 마지막 프로세스의 종료코드를 저장

### 배운 점
- 자식프로세스를 생성하는 heredoc이나 cmd실행에서, SIGINT 등을 했을때 다같이 종료되거나 표준입력이 이상해지는 현상
  - 시그널은 부모와 자식 모두에게 전달되기때문에, heredoc은 fork직후, cmd실행은 실행 직전(다른프로세스로 덮어씌워지므로)에 시그널을 무시하게 처리
- 천개 이상의 명령어가 파이프를 통해 잘 전달되게 하기 위한 IPC 기본 이해
  - ls와 echo같은 출력만 하는 프로그램은 잘 되지만 cat과 같은 입력이 들어가는 프로그램 실행시 제대로 안되는 문제 -> EOF를 통한 SIGPIPE를 이용하여 해결
  - 이전 파이프관련 과제에서는 명령어 갯수 -1 개만큼 파이프를 만들어서 데이터를 공유했으나, 운영체제에서 프로세스별 fd 최대 제한이 존재함
  - fork()시에 부모프로세스의 모든것이 복제되는 특성을 이용해 부모프로세스에서 최대2개의 파이프를 이용해 모든 자식프로세스들의 입출력을 연결함
- 스페이스 뿐 아니라 파이프 앞뒤로 문자와 붙어있거나 리다이렉션문자가 파일이름과 붙어있더라도 정상적으로 작동하는 이유는 메타캐릭터의 문자들을 기준으로 토큰화가 되어있기 때문
- heredoc 구현을 임시파일로 했을 때, 파일이름이 이미 존재할 경우 원본파일이 덮어씌워지므로 파일 유실이 될 수 있음
  - 해당 파일이름을 기준으로 뒤에 숫자를 1씩 증가시켜가며 존재유무를 파악해 중복 회피
- 입력이 존재하는 프로그램에서 상당수의 오류는 입력의 잘못된 파싱으로 인한 것이므로 파싱이 정말 중요함
- 명령어가 몇개나 들어올지, 들어올 문자열의 길이 등을 알수 없기 때문에 대부분 동적메모리 할당 및 사용완료시 해제로 누수 해결